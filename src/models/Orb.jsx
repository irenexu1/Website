/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Tycho Magnetic Anomaly (https://sketchfab.com/Tycho_Magnetic_Anomaly)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/cyber-orb-8a81aa847da74a5cb36bd8ba13f6ae5e
Title: Cyber Orb
*/

import { useMemo, useRef, useState } from "react";
import { useFrame, useLoader } from "@react-three/fiber";
import { useGLTF, useAnimations, Decal } from '@react-three/drei'
import * as THREE from "three";


function makeTextTexture(text) {
  const size = 512;
  const c = document.createElement("canvas");
  c.width = size;
  c.height = size;
  const ctx = c.getContext("2d");

  ctx.clearRect(0, 0, size, size); // transparent background
  ctx.fillStyle = "#ff1a8c"; // Change to any color: "#ffaa00", "#00ff00", etc.
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = "bold 72px Arial";
  ctx.fillText(text, size / 2, size / 2);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.needsUpdate = true;
  return tex;
}


export default function Orb({ id = 0, label = "", imagePath = "", imageScale = 1.5, position = [0, 0, 0], onSelect, ...props}) {
   const ref = useRef();

   const spinRef = useRef();

   const dragging = useRef(false);
   const last = useRef({x:0, y:0});
   const velocity = useRef({ x: 0, y: 0 })
   const damping = 0.92 // closer to 1 = longer glide
   const sensitiviy = 0.01

   // Load image texture if provided
   const imageTexture = imagePath ? useLoader(THREE.TextureLoader, imagePath) : null;

   const { nodes, materials } = useGLTF('/cyber_orb.glb');
   
   const mats = useMemo(() => {
    const shell = materials.shell.clone();
    shell.transparent = true;
    shell.opacity = 0.8;
    shell.color.set('#968cff'); 
    shell.emissive.set('#adbfff');
    shell.emissiveIntensity = 0.5;
    
    const core = materials.material.clone();
    
    const frame = materials.frame.clone();
    frame.color.set('#e3f2ff'); 
    frame.emissive.set('#b5c4ff');
    frame.emissiveIntensity = 4;
    frame.toneMapped = true;
    
    return {shell, core, frame,};
   }, [materials]);
   
   const labelTex = useMemo(() => makeTextTexture(label), [label]);

   const onPointerDown = (e) => {
    e.stopPropagation();
    dragging.current = true;
    last.current.x = e.clientX;
    last.current.y = e.clientY;
    e.target.setPointerCapture?.(e.pointerId)
   }

   const onPointerUp = (e) => {
    dragging.current = false;
    e.target.releasePointerCapture?.(e.pointerId)
   } 

   const onPointerMove = (e) => {
    if (!dragging.current || !spinRef.current) return;
    e.stopPropagation();

    const dx = e.clientX - last.current.x
    const dy = e.clientY - last.current.y
    last.current.x = e.clientX
    last.current.y = e.clientY
    
    const vy = dx * sensitiviy
    const vx = dy * sensitiviy

    // tweak sensitivity to taste
    spinRef.current.rotation.y += vy
    spinRef.current.rotation.x += vx

    // store velocity for momentum (simple smoothing)
    velocity.current.y = vy
    velocity.current.x = vx
   }


   useFrame(({clock}, delta) => {
    if (!ref.current) return;
    const t = clock.getElapsedTime() + id * 0.6;
    ref.current.position.y = position[1] + Math.sin(t) * 0.12;

    // 2) momentum rotation (inner group)
    if (!spinRef.current) return

    if (!dragging.current) {
        spinRef.current.rotation.y += velocity.current.y
        spinRef.current.rotation.x += velocity.current.x

        const d = Math.pow(damping, delta * 60)
        velocity.current.y *= d
        velocity.current.x *= d

    if (Math.abs(velocity.current.y) < 0.00001) velocity.current.y = 0
    if (Math.abs(velocity.current.x) < 0.00001) velocity.current.x = 0
    }
   });


  return (
  <group ref={ref} position={position} 
    onPointerDown={onPointerDown}
    onPointerUp={onPointerUp}
    onPointerLeave={onPointerUp}
    onPointerMove={onPointerMove}
    {...props} dispose={null}>
    <group ref={spinRef}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group name="root">
            <group name="GLTF_SceneRootNode" rotation={[Math.PI / 2, 0, 0]}>
              <group name="Sphere001_0">
                <mesh
                  name="Object_4"
                  castShadow
                  receiveShadow
                  geometry={nodes.Object_4.geometry}
                  material={mats.shell}
                >
                  {imageTexture && (
                    <Decal
                      position={[0, 0, 1]}
                      rotation={[0, 0, 0]}
                      scale={imageScale}
                      map={imageTexture}
                      transparent
                      polygonOffset
                      polygonOffsetFactor={-1}
                    />
                  )}
                </mesh>
              </group>
              <group name="Sphere002_1" scale={0.72}>
                <mesh
                  name="Object_6"
                  castShadow
                  receiveShadow
                  geometry={nodes.Object_6.geometry}
                  material={mats.core}
                />
              </group>
              <group name="Sphere003_2" />
              <group name="Sphere004_3">
                <mesh
                  name="Object_9"
                  castShadow
                  receiveShadow
                  geometry={nodes.Object_9.geometry}
                  material={mats.frame}
                />
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  </group>
  )
}

useGLTF.preload('/cyber_orb.glb')
